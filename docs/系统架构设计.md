# 系统架构设计

## 1. 架构概览
系统采用前后端分离架构：
- 三个基于 Vue3 + Vite + TypeScript 的独立前端项目（演讲者端、观众端、后台端）。
- 一个基于 Go + Gin 的后端服务，提供 REST API 与 WebSocket 服务。
- 外部依赖：Google Speech-to-Text（Streaming 模式）与 Google Cloud Translation API。
- 部署环境：AWS EC2（Ubuntu LTS），使用 Docker 容器化，容器间通过 docker-compose 编排。

```
演讲者浏览器 ─┐
                 │ WebSocket 推流
观众浏览器 ──────┼──────> Go 后端 ──> Google STT
                 │             │
后台浏览器 ─────┘             └──> Google Translation
                              │
                              └──> 缓存（字幕历史、令牌、二维码状态）
```

## 2. 组件划分
### 2.1 前端
- **演讲者端（orion-speaker-web）**：音频采集、语种选择、原文/译文展示、状态反馈。
- **观众端（orion-viewer-web）**：语言订阅、字幕展示、历史回滚，采用移动优先设计并支持二维码扫码入口。
- **后台端（orion-admin-web）**：活动与权限管理、资源上传、生成观众端二维码并提供下载、失效操作。

三个项目共享统一的 UI 设计规范与组件库，可通过 Git 子模块或 npm 私有包形式复用组件与工具函数（如 WebSocket 客户端 SDK、语言常量、主题样式、二维码组件等）。

### 2.2 后端
- **API 层**：Gin 路由，负责 HTTP/API、WebSocket 协议解析与认证。
- **应用服务层**：封装业务流程（活动管理、翻译广播、缓存管理、二维码生成与失效）。
- **领域层**：定义核心领域模型（活动、字幕句子、订阅语言、用户令牌、观众入口）。
- **基础设施层**：实现 Google API 适配器、缓存（Redis/内存）、文件存储适配器、二维码生成器、配置加载。

## 3. 关键流程
### 3.1 演讲者推流与翻译
1. 演讲者端建立 WebSocket 连接并发送认证令牌与输入语种。
2. 后端创建 Google Streaming Speech-to-Text 会话，将音频块透传。
3. Google STT 返回识别结果（逐句 Final），后端转发给翻译服务。
4. Google Translation 输出多语言译文，后端根据观众订阅的语言分发。
5. 后端同时写入短期缓存，供观众端历史回看。

### 3.2 观众订阅与字幕分发
1. 观众通过扫码后台生成的二维码或输入邀请码访问观众端，并建立 WebSocket 连接。
2. 后端校验活动状态与令牌有效性，建立语言频道订阅。
3. 当新的字幕生成时，后端按语言广播文本。
4. 观众端接收消息，按移动优先布局滚动展示实时字幕，并可查询历史缓存。

### 3.3 后台活动管理
1. 管理员通过 JWT 登录后台。
2. 使用 REST API 创建/编辑活动，配置输入/输出语种、时间、简介、封面。
3. 活动创建成功后进入“创建成功”页面，立即展示观众端访问二维码，可下载或复制链接。
4. 后台可在活动详情中随时使二维码失效（例如活动结束后自动或手动失效），避免过期链接继续传播。
5. 上传的图片/资料存储至对象存储（可使用 AWS S3 或后续扩展）。

## 4. 数据流设计
- **输入数据**：浏览器麦克风音频流（浏览器捕获的 PCM/Opus），经 WebSocket 发送。可在前端对音频作基础压缩以降低延迟与带宽。
- **处理数据**：
  - STT 输出原文句子、置信度、时间戳。
  - Translation 输出多语句子。
  - 后端打包为内部消息格式 `{sentenceId, original, translations{lang: text}, timestamp}`。
- **输出数据**：按语言频道推送 JSON 消息。观众端根据 `lang` 字段过滤。
- **二维码数据**：后台生成观众端访问链接（直接指向观众端活动页面），使用后端库生成 PNG/SVG/Base64，在前端显示并可下载；二维码状态与有效期与活动状态同步。
- **缓存策略**：使用内存或 Redis 保留最近 N 条字幕（时间窗口 5 分钟）及二维码状态。

## 5. 通信协议
- **WebSocket**：
  - 演讲者 → 后端：`audio` 消息（包含音频二进制/BASE64）、`control` 消息（开始/结束）。
  - 后端 → 观众：`subtitle` 消息（包含原文、目标语言文本、时间戳)。
  - 心跳机制：后端每 30 秒发送 ping/pong，检测连接状态。
- **REST API**：
  - 活动、令牌、资源管理、二维码生成/失效等 CRUD 操作。
  - Google API 配置信息仅在后端持有，不向前端暴露。

## 6. 安全设计
- 所有前端通过 HTTPS/WSS 与后端通信。
- 演讲者与观众需要提供有效令牌或邀请码（JWT），后端验证签名与有效期。
- 管理员账户在后台单独维护，推荐启用 2FA（后续迭代）。
- Google API 凭证使用服务账户，存储在 EC2 的安全目录或 AWS Secrets Manager。
- 二维码链接仅在活动有效期内可用，活动关闭后对应链接返回提示页面。

## 7. 部署拓扑
- 单台 EC2（初期，可扩展）：
  - 反向代理（Nginx）负责 TLS 终止、静态资源分发、二维码静态文件提供。
  - 后端服务容器（Go）提供 API 与 WebSocket。
  - 前端项目构建后通过 Nginx 提供静态页面（也可部署至 S3 + CloudFront）。
- 生产环境推荐使用多可用区部署与 ELB 负载均衡；当前规模可先采用单实例+自动备份策略。

## 8. 可扩展性设计
- 通过水平扩容（多实例） + Redis Pub/Sub 实现字幕广播的跨实例同步。
- 将活动与用户信息持久化到数据库（PostgreSQL/Firestore），为多活动并行铺路。
- 引入消息队列（如 NATS/Kafka）处理更复杂的翻译管线和语料分析。
- 后续如需短链、短信推送等扩展，可在二维码模块外另行拓展。

## 9. 性能与可靠性
- 减少网络延迟：音频分片大小约 100-200ms，使用前端 Web Worker 处理编码。
- 后端非阻塞处理：Go 协程与 channel 实现音频流、STT 响应、翻译广播的流水线。
- 错误恢复：若 Google 服务临时不可用，系统提示观众“翻译暂时不可用”并自动重试。
- 二维码生成失败时提供回退策略（显示纯文本链接供复制）。

## 10. 监控与日志
- 后端记录关键日志：连接建立/关闭、API 错误、外部服务调用耗时、二维码生成与失效操作。
- 配置基础指标采集（CPU、内存、WebSocket 连接数、翻译成功率、二维码下载量）。
- 未来可接入 Prometheus + Grafana 或 AWS CloudWatch 实现可视化监控。
