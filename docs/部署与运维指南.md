# 部署与运维指南

## 1. 环境要求
- 平台：AWS EC2（Ubuntu 22.04 LTS 推荐）。
- 规格：t3.medium（2 vCPU / 4GB RAM）起步，根据并发情况可调整。
- 网络：开放 80/443 端口供 HTTP/HTTPS 访问；开放 22 端口供运维（建议配合 IP 白名单）；WebSocket 复用 443。
- 前置依赖：Docker、docker-compose、Nginx、Certbot（HTTPS 证书）。
- 二维码由后端 Go 服务生成，无需额外服务。

### 1.1 本地开发环境（参考）
- 操作系统：macOS / Linux
- 必备工具：Go 1.25+、Node.js 18+、pnpm、PostgreSQL 16、Redis（可选）
- 常用端口：
  | 服务 | 端口 | 说明 |
  | --- | --- | --- |
  | PostgreSQL | 5432 | 本地开发数据库 |
  | Go Backend | 8080 | REST / WebSocket 服务 |
  | Vite Dev Server | 5173 | 演讲者端前端调试 |

#### PostgreSQL 启停脚本
仓库提供 `scripts/postgres-dev.sh`，封装了 `start|stop|status|restart`：

```bash
# 启动本地数据库
./scripts/postgres-dev.sh start

# 停止数据库
./scripts/postgres-dev.sh stop

# 查看状态
./scripts/postgres-dev.sh status
```

如 PostgreSQL 安装在其他路径，可通过环境变量覆盖：

```
PG_BIN_DIR=/usr/local/pgsql/bin PG_DATA_DIR=/var/lib/postgresql/data ./scripts/postgres-dev.sh start
```

> 注意：本地数据库仅用于开发调试，生产环境推荐使用 AWS RDS 等托管实例，并独立配置凭据、备份与监控。

### 1.2 数据库迁移
- **工具**：应用启动时将自动执行内置迁移（`internal/infra/database/migrate.go`），确保三张核心表存在。
- **手动执行**：在生产或预发环境首次部署前，可先运行一次二进制 `go run cmd/server/main.go --migrate-only`（后续计划接入 CLI）或执行 docs/数据库迁移与上线SOP.md 中给出的 SQL。
- **迁移注意事项**：
  - 所有表都使用 `UUID` 作为主键，若需要导入历史数据需保证唯一。
  - `activity_tokens` 对 `(activity_id, type, value)` 做唯一约束，避免重复令牌。
  - `viewer_entries` 与活动一对一，更新时覆盖原记录。

### 1.3 AWS RDS（PostgreSQL）上线建议
1. 选择 `db.t3.medium` 起步，开启多可用区部署、自动备份（至少 7 天）。
2. 创建安全组：允许来自应用子网/EC2 的 5432 访问；禁止公共访问。
3. 创建 `orion_app`（LOGIN）账号，并授予 `orion_prod` 数据库所有权限；运维账号独立创建。
4. 将 `DATABASE_URL` 设置为 `postgres://orion_app:<PASSWORD>@<RDS_ENDPOINT>:5432/orion_prod?sslmode=require`。
5. 首次部署前执行迁移脚本（参考附录）；执行完成后锁定账号权限（禁止创建数据库）。
6. 配置 CloudWatch 告警：连接数、CPU、FreeStorageSpace，设置 80% 阈值告警。

## 2. 部署流程概览
1. 准备 EC2 实例，配置安全组与密钥。
2. 安装系统依赖（Docker、docker-compose、Git、Nginx、ufw）。
3. 拉取项目仓库，设置 `.env` 文件。
4. 构建前端项目，生成静态文件（观众端重点验证移动端展示）。
5. 构建后端 Docker 镜像，配置 docker-compose。
6. 配置 Nginx 作为反向代理（TLS 终止 + 静态资源 + WebSocket 转发）。
7. 申请 HTTPS 证书（Let’s Encrypt），设置自动续签。
8. 启动服务，验证功能。

## 3. 配置文件示例
### 3.1 `.env`（后端）
```
APP_PORT=8080
APP_ENV=production
JWT_SECRET_PATH=/secrets/jwt_private.pem
GOOGLE_APPLICATION_CREDENTIALS=/secrets/google-service-account.json
REDIS_URL=redis://redis:6379/0
WS_PING_INTERVAL=30s
HISTORY_CACHE_TTL=5m
VIEWER_BASE_URL=https://orion.example.com
```

### 3.2 `docker-compose.yml`
```yaml
version: "3.9"
services:
  backend:
    build: ./backend
    env_file: .env
    volumes:
      - ./secrets:/secrets:ro
    ports:
      - "8080:8080"
    depends_on:
      - redis
  redis:
    image: redis:7-alpine
    command: ["redis-server", "--save", "", "--appendonly", "no"]
    ports:
      - "6379:6379"
```

### 3.3 Nginx 反向代理
```
server {
    listen 80;
    server_name orion.example.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name orion.example.com;

    ssl_certificate /etc/letsencrypt/live/orion.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/orion.example.com/privkey.pem;

    location / {
        root /var/www/orion-viewer;
        try_files $uri $uri/ /index.html;
    }

    location /speaker {
        alias /var/www/orion-speaker;
        try_files $uri $uri/ /index.html;
    }

    location /admin {
        alias /var/www/orion-admin;
        try_files $uri $uri/ /index.html;
    }

    location /api/ {
        proxy_pass http://127.0.0.1:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    location /ws/ {
        proxy_pass http://127.0.0.1:8080/ws/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_read_timeout 600s;
    }
}
```

## 4. 部署步骤详解
1. **准备服务器**：更新系统、创建部署用户、配置防火墙。
2. **安装 Docker**：按照官方脚本安装 Docker Engine 与 docker-compose。
3. **拉取代码**：`git clone` 项目仓库至 `/opt/orion`。
4. **配置 Secrets**：将 Google 服务账户、JWT 私钥放在 `/opt/orion/secrets`，设置权限。
5. **构建前端**：进入 `front-end/apps/*` 执行 `pnpm install && pnpm build`，将 `dist` 上传至 `/var/www` 对应目录。
6. **构建后端**：`docker-compose build`，确认镜像生成。
7. **启动服务**：`docker-compose up -d`，检查容器日志。
8. **配置 Nginx**：放置配置文件，测试 `nginx -t`，重载 `systemctl reload nginx`。
9. **申请证书**：使用 Certbot `certbot --nginx -d orion.example.com`。
10. **上线验证**：
    - 演讲者端推送音频并确认翻译返回；
    - 后台成功创建活动后检查二维码显示、下载、失效按钮；
    - 观众端在手机浏览器中扫码访问并验证字幕展示。

## 5. 运维日常
- **日志查看**：`docker-compose logs -f backend`，或使用 ELK/CloudWatch。
- **服务更新**：拉取最新代码 → 构建 → `docker-compose up -d --build`。
- **证书续期**：Certbot 默认自动续签，检查 `systemctl status certbot.timer`。
- **二维码维护**：活动结束后确认二维码失效状态，避免旧链接继续传播。
- **备份策略**：备份配置、Secrets、Docker Compose 文件。若启用 Redis 持久化或数据库，需定期备份数据。

## 6. 故障排查
| 问题 | 排查步骤 | 解决建议 |
| --- | --- | --- |
| 无法访问站点 | 检查 Nginx、Docker 服务状态 | 重启服务，查看错误日志 |
| WebSocket 连接失败 | 浏览器控制台/后端日志 | 检查 HTTPS 证书、WS 路径、端口防火墙 |
| 翻译延迟严重 | 查看 Google API 响应时间 | 调整音频分片、检查网络带宽、启用区域就近节点 |
| Google API 错误 | 检查凭证与配额 | 申请更高配额、开启自动重试 |
| 二维码显示异常 | 检查 `/api/v1/activities/{id}/viewer-entry` 返回值 | 确认活动状态、邀请码有效性、VIEWER_BASE_URL 设置正确 |

## 7. 未来运维优化
- 引入 CI/CD（GitHub Actions）实现自动构建与部署。
- 使用 Terraform 管理基础设施，提升可重复性。
- 接入 Prometheus/Grafana 或 AWS CloudWatch 监控指标与告警（含二维码生成次数、扫码失败率）。
- 将前端静态资源迁移至 S3 + CloudFront，降低服务器压力。
